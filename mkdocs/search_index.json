{
    "docs": [
        {
            "location": "/", 
            "text": "About ArrayFire\n\n\n\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"\n\n\nYou can read its introduction \nint its documentation's index page\n. It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just \nawesome\n. It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.\n\n\nAbout ArrayFire.js\n\n\nArrayFire.js is the Node.js bindings for ArrayFire, it uses \nCMake.js\n as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).\n\n\nInstall instructions can be found in the \nproject's readme at Github\n.\n\n\n(How To) Use ES6 Generators\n\n\nThe original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:\n\n\nfire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});\n\n\n\n\nYeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous ArrayFire.js method has two counterparts. One synchronous, ends with \n\"Sync\"\n (eg. \nsqrtSync\n). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a \nBluebird promise\n, ends with \n\"Async\"\n (eg. \nsqrtAsync\n). Wrap an \nES6 generator function\n by a \ncoroutine\n, and you can yield those promises from there:\n\n\nlet async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});\n\n\n\n\nAnd voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those \nasync/await features\n that C# guys have! (Of course you can use some other coroutine library, like \nco\n.)\n\n\nTo run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.\n\n\nEven you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. ArrayFire.js uses that method too. It has been developed in ES6, and uses \nGulp/Traceur\n and \nfeature detection\n to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.\n\n\nAPI\n\n\nIn ArrayFire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.\n\n\nAll asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with \nAsync\n and \nSync\n endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.\n\n\nSmall Example\n\n\nPort of the PI calculator from \nArrayFire documentation\n:\n\n\nC++\n\n\n// sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum\nfloat\n(dist \n 1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);\n\n\n\n\nJavaScript\n\n\nconst numberOfPoints = 20000000;\n\n// ...\n\nlet x = af.randu(numberOfPoints, af.dtype.f32);\nlet y = af.randu(numberOfPoints, af.dtype.f32);\nlet dist = af.sqrt(x.mul(x).add(y.mul(y)));\nlet numInside = yield af.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  numInside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);\n\n\n\n\nIt's included in the \nexamples folder\n. To run on:\n\n\n\n\nio.js, enter: \niojs examples/es6/bechmarks/pi.js\n\n\nNode.js 0.12 or above, enter: \nnode --harmony examples/es6/bechmarks/pi.js\n\n\nNode.js below 0.12, enter: \nnode examples/es5/bechmarks/pi.js\n\n\n\n\nLicense\n\n\nNew BSD", 
            "title": "Home"
        }, 
        {
            "location": "/#about-arrayfire", 
            "text": "\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"  You can read its introduction  int its documentation's index page . It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just  awesome . It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.", 
            "title": "About ArrayFire"
        }, 
        {
            "location": "/#about-arrayfirejs", 
            "text": "ArrayFire.js is the Node.js bindings for ArrayFire, it uses  CMake.js  as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).  Install instructions can be found in the  project's readme at Github .", 
            "title": "About ArrayFire.js"
        }, 
        {
            "location": "/#how-to-use-es6-generators", 
            "text": "The original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:  fire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});  Yeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous ArrayFire.js method has two counterparts. One synchronous, ends with  \"Sync\"  (eg.  sqrtSync ). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a  Bluebird promise , ends with  \"Async\"  (eg.  sqrtAsync ). Wrap an  ES6 generator function  by a  coroutine , and you can yield those promises from there:  let async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});  And voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those  async/await features  that C# guys have! (Of course you can use some other coroutine library, like  co .)  To run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.  Even you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. ArrayFire.js uses that method too. It has been developed in ES6, and uses  Gulp/Traceur  and  feature detection  to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.", 
            "title": "(How To) Use ES6 Generators"
        }, 
        {
            "location": "/#api", 
            "text": "In ArrayFire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.  All asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with  Async  and  Sync  endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.", 
            "title": "API"
        }, 
        {
            "location": "/#small-example", 
            "text": "Port of the PI calculator from  ArrayFire documentation :  C++  // sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum float (dist   1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);  JavaScript  const numberOfPoints = 20000000;\n\n// ...\n\nlet x = af.randu(numberOfPoints, af.dtype.f32);\nlet y = af.randu(numberOfPoints, af.dtype.f32);\nlet dist = af.sqrt(x.mul(x).add(y.mul(y)));\nlet numInside = yield af.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  numInside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);  It's included in the  examples folder . To run on:   io.js, enter:  iojs examples/es6/bechmarks/pi.js  Node.js 0.12 or above, enter:  node --harmony examples/es6/bechmarks/pi.js  Node.js below 0.12, enter:  node examples/es5/bechmarks/pi.js", 
            "title": "Small Example"
        }, 
        {
            "location": "/#license", 
            "text": "New BSD", 
            "title": "License"
        }, 
        {
            "location": "/AFArray/", 
            "text": "AFArray class\n\n\n-\n ArrayFire Documentation\n\n\nTOC\n\n\n\n\n\n\n\n\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\n\n\n\n\nconstructor\n\n\nMethods\n\n\nelements()\n\n\nhost()\n\n\ncopyToHost()\n\n\nscalar()\n\n\nvalue()\n\n\nwrite()\n\n\ntype()\n\n\ndims()\n\n\nnumdims()\n\n\nnumDims()\n\n\nbytes()\n\n\nas()\n\n\ncopy()\n\n\nisempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()\n\n\neval()\n\n\n\n\n\n\nIndexing Operations\n\n\nat()\n\n\nrow(), rows()\n\n\ncol(), cols()\n\n\nslice(), slices()\n\n\n\n\n\n\nAssignment Operators\n\n\nArithmetic Operators\n\n\nLogical Operators\n\n\n\n\n\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\nasynchronous, counterparts: \ncreateAsync\n, \ncreateSync\n\n\nCreates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the \nsource\n argument specifies its location.\n\n\n\n\ncreate(dim0, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, dim3, type, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dims, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nconstructor\n\n\nArrays could be created as empty ones or by having a specified dimensions and element type. \n\n\n\n\nnew AFArray()\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nRemarks:\n\n\nIn Fire.js \ntype\n argument is \nnot optional\n.\n\n\nMethods\n\n\nelements()\n\n\nGet the number of elements in array.\n\n\n\n\nelements()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n Number\n\n\nhost()\n\n\nCopy array data to host.\n\n\nasynchronous, counterparts: \nhostAsync\n, \nhostSync\n\n\n\n\nhost(callback)\n \n-\n ArrayFire Documentation\n\n\nhost(buffer, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - to hold array's values, must be atleast the size of the array.\n\n\n\n\nResult:\n if buffer is not specified, then it will be created and returned, otherwise the result is \nundefined\n\n\ncopyToHost()\n\n\nalias of \nhost\n\n\nscalar()\n\n\nasynchronous, counterparts: \nscalarAsync\n, \nscalarSync\n\n\nGet scalar value from the array (if its size is larger than one in any dimensions it gives the first value).\n\n\n\n\nscalar(callback)\n\n\n\n\nResult: Boolean|Number|String|\nComplex\n value in the array, type depends on the array's type.\n\n\nvalue()\n\n\nalias of \nscalar()\n\n\nwrite()\n\n\nPerform deep copy from host/device pointer to an existing array.\n\n\n\n\nwrite(buffer, bytesToCopy, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - data to copy to the array, or device pointer created by the \nalloc\n method.\n\n\nbytesToCopy\n: bytes to copy\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\ntype()\n\n\n\n\ntype()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's element type, can be one of the values of \ndType\n object\n\n\ndims()\n\n\n\n\ndims()\n \n-\n ArrayFire Documentation\n\n\ndims(n)\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n\n- of \ndims()\n: array's dimensions info in a \nDim4\n object instance\n- of \ndims(n)\n: size of the specified dimension\n\n\nnumdims()\n\n\n\n\nnumdims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n number of dimensions of the array\n\n\nnumDims()\n\n\nalias of \nnumdims\n\n\nbytes()\n\n\n\n\nbytes()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n size of the array in bytes\n\n\nas()\n\n\nConverts the array into another type. \n\n\n\n\nas(type)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult:\n AFArray instance holding reference the converted array\n\n\ncopy())`\n\n\n\n\ncopy()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n new AFArray instance holding a deep copy of the array\n\n\nisempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()\n\n\naliases respectively: \nisEmpty\n, \nisScalar\n, \nisVector\n, \nisRow\n, \nisColumn\n, \nisComplex\n, \nisReal\n, \nisDouble\n, \nisSingle\n, \nisRealFloating\n, \nisFloating\n, \nisInteger\n, \nisBool\n \n\n\n\n\nis\nanything\n() \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n actual type info (Boolean)\n\n\neval()\n\n\n\n\neval()\n \n-\n ArrayFire Documentation\n\n\n\n\nEvaluate any JIT expressions to generate data for the array.\n\n\nIndexing Operations\n\n\nat()\n\n\n-\n ArrayFire Documentation\n\n\n\n\nat(s0)\n\n\nat(s0, s1)\n\n\nat(s0, s1, s2)\n\n\nat(s0, s1, s2, s3)\n\n\nat(def)\n\n\n\n\nArguments\n:\n\n\n\n\ns0 .. s3: null|String|Number|\nSeq\n|AFArray\n \n\n\nnull:\n means \n\"span\"\n\n\nString:\n can be \n\"span\"\n\n\nNumber:\n element's index, or -1 which means the last element\n\n\nSeq\n:\n sequence of values\n\n\nAFArray:\n array holding the index value\n\n\n\n\n\n\ndef\n: \nRow\n|\nRows\n|\nCol\n|\nCols\n|\nSlice\n|\nSlices\n\n\nRow\n: specified row\n\n\nRows\n: specified rows\n\n\nCol\n: specified column\n\n\nCols\n: specified columns\n\n\nSlice\n: specified slice\n\n\nSlices\n: specified slices\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding reference to the the specified region of the original array\n\n\nrow(), rows()\n\n\nGets a reference of a row in a 2D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\nrow(index)\n\n\nrows(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a row index or a range of row indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 2D array\n\n\ncol(), cols()\n\n\nGets a reference of a column in a 2D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\ncol(index)\n\n\ncols(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a column index or a range of column indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 2D array\n\n\nslice(), slices()\n\n\nGets a reference of a matrix in a 3D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\nslice(index)\n\n\nslices(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a matrix index or a range of matrix indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 3D array\n\n\nAssignment Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nassign(other)\n operator =\n\n\nset(other)\n operator = (alias of assign)\n\n\naddAssign(other)\n operator +=\n\n\nsubAssign(other)\n operator -=\n\n\nmulAssign(other)\n operator *=\n\n\ndivAssign(other)\n operator /=\n\n\nassign(s0, other)\n operator =\n\n\nset(s0, other)\n operator = (alias of assign)\n\n\naddAssign(s0, other)\n operator +=\n\n\nsubAssign(s0, other)\n operator -=\n\n\nmulAssign(s0, other)\n operator *=\n\n\ndivAssign(s0, other)\n operator /=\n\n\nassign(s0, s1, other)\n operator =\n\n\nset(s0, s1, other)\n operator = (alias of assign)\n\n\naddAssign(s0, s1, other)\n operator +=\n\n\nsubAssign(s0, s1, other)\n operator -=\n\n\nmulAssign(s0, s1, other)\n operator *=\n\n\ndivAssign(s0, s1, other)\n operator /=\n\n\nassign(s0, s1, s2, other)\n operator =\n\n\nset(s0, s1, s2, other)\n operator = (alias of assign)\n\n\naddAssign(s0, s1, s2, other)\n operator +=\n\n\nsubAssign(s0, s1, s2, other)\n operator -=\n\n\nmulAssign(s0, s1, s2, other)\n operator *=\n\n\ndivAssign(s0, s1, s2, other)\n operator /=\n\n\nassign(s0, s1, s2, s3, other)\n operator =\n\n\nset(s0, s1, s2, s3, other)\n operator = (alias of assign)\n\n\naddAssign(s0, s1, s2, s3, other)\n operator +=\n\n\nsubAssign(s0, s1, s2, s3, other)\n operator -=\n\n\nmulAssign(s0, s1, s2, s3, other)\n operator *=\n\n\ndivAssign(s0, s1, s2, s3, other)\n operator /=\n\n\nassign(def, other)\n operator =\n\n\nset(def, other)\n operator = (alias of assign)\n\n\naddAssign(def, other)\n operator +=\n\n\nsubAssign(def, other)\n operator -=\n\n\nmulAssign(def, other)\n operator *=\n\n\ndivAssign(def, other)\n operator /=\n\n\n\n\nArguments\n:\n\n\n\n\ns0 .. s3: null|String|Number|\nSeq\n|AFArray\n lhs index\n\n\nnull:\n means \n\"span\"\n\n\nString:\n can be \n\"span\"\n\n\nNumber:\n element's index, or -1 which means the last element\n\n\nSeq\n:\n sequence of values\n\n\nAFArray:\n array holding the index value\n\n\n\n\n\n\ndef\n: \nRow\n|\nRows\n|\nCol\n|\nCols\n|\nSlice\n|\nSlices\n\n\nRow\n: specified row\n\n\nRows\n: specified rows\n\n\nCol\n: specified column\n\n\nCols\n: specified columns\n\n\nSlice\n: specified slice\n\n\nSlices\n: specified slices\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n assignee AFArray instance\n\n\nArithmetic Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nadd(other)\n operator +\n\n\nsub(other)\n operator -\n\n\nmul(other)\n operator *\n\n\ndiv(other)\n operator /\n\n\nbitshiftl(other)\n operator \n\n\nbitShiftL(other)\n operator \n (alias of bitshiftl)\n\n\nbitshiftr(other)\n operator \n\n\nbitShiftR(other)\n operator \n (alias of bitshiftr)\n\n\n\n\nArguments\n:\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding the operation's result\n\n\nLogical Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nneg()\n operator -\n\n\nnot()\n operator !\n\n\nlt(other)\n operator \n\n\ngt(other)\n operator \n\n\nle(other)\n operator \n=\n\n\nge(other)\n operator \n=\n\n\neq(other)\n operator ==\n\n\nneq(other)\n operator !=\n\n\nand(other)\n operator \n\n\nor(other)\n operator ||\n\n\nbitAnd(other)\n operator \n\n\nbitOr(other)\n operator |\n\n\nbitXor(other)\n operator ^\n\n\n\n\nArguments\n:\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding the operation's result", 
            "title": "AFArray"
        }, 
        {
            "location": "/AFArray/#afarray-class", 
            "text": "-  ArrayFire Documentation", 
            "title": "AFArray class"
        }, 
        {
            "location": "/AFArray/#toc", 
            "text": "Staitc methods  AFArray.create()    constructor  Methods  elements()  host()  copyToHost()  scalar()  value()  write()  type()  dims()  numdims()  numDims()  bytes()  as()  copy()  isempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()  eval()    Indexing Operations  at()  row(), rows()  col(), cols()  slice(), slices()    Assignment Operators  Arithmetic Operators  Logical Operators", 
            "title": "TOC"
        }, 
        {
            "location": "/AFArray/#staitc-methods", 
            "text": "AFArray.create()  asynchronous, counterparts:  createAsync ,  createSync  Creates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the  source  argument specifies its location.   create(dim0, type, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, type, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, type, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, dim3, type, buffer, source, callback)   -  ArrayFire Documentation  create(dims, buffer, source, callback)   -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  source: value of  source  - can be one of the values of source object (eg.  source.host )   Result : the created AFArray instance.", 
            "title": "Staitc methods"
        }, 
        {
            "location": "/AFArray/#constructor", 
            "text": "Arrays could be created as empty ones or by having a specified dimensions and element type.    new AFArray() :  -  ArrayFire Documentation  new AFArray(dim0, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  new AFArray(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Remarks:  In Fire.js  type  argument is  not optional .", 
            "title": "constructor"
        }, 
        {
            "location": "/AFArray/#methods", 
            "text": "elements()  Get the number of elements in array.   elements()   -  ArrayFire Documentation   Result:  Number  host()  Copy array data to host.  asynchronous, counterparts:  hostAsync ,  hostSync   host(callback)   -  ArrayFire Documentation  host(buffer, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - to hold array's values, must be atleast the size of the array.   Result:  if buffer is not specified, then it will be created and returned, otherwise the result is  undefined  copyToHost()  alias of  host  scalar()  asynchronous, counterparts:  scalarAsync ,  scalarSync  Get scalar value from the array (if its size is larger than one in any dimensions it gives the first value).   scalar(callback)   Result: Boolean|Number|String| Complex  value in the array, type depends on the array's type.  value()  alias of  scalar()  write()  Perform deep copy from host/device pointer to an existing array.   write(buffer, bytesToCopy, source, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - data to copy to the array, or device pointer created by the  alloc  method.  bytesToCopy : bytes to copy  source: value of  source  - can be one of the values of source object (eg.  source.host )   type()   type()   -  ArrayFire Documentation   Result:  array's element type, can be one of the values of  dType  object  dims()   dims()   -  ArrayFire Documentation  dims(n)   -  ArrayFire Documentation   Result: \n- of  dims() : array's dimensions info in a  Dim4  object instance\n- of  dims(n) : size of the specified dimension  numdims()   numdims()   -  ArrayFire Documentation   Result:  number of dimensions of the array  numDims()  alias of  numdims  bytes()   bytes()   -  ArrayFire Documentation   Result:  size of the array in bytes  as()  Converts the array into another type.    as(type)   -  ArrayFire Documentation   Arguments:   type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result:  AFArray instance holding reference the converted array  copy())`   copy()   -  ArrayFire Documentation   Result:  new AFArray instance holding a deep copy of the array  isempty(), isscalar(), isvector(), isrow(), iscolumn(), iscomplex(), isreal(), isdouble(), issingle(), isrealfloating(), isfloating(), isinteger(), isbool()  aliases respectively:  isEmpty ,  isScalar ,  isVector ,  isRow ,  isColumn ,  isComplex ,  isReal ,  isDouble ,  isSingle ,  isRealFloating ,  isFloating ,  isInteger ,  isBool     is anything ()  -  ArrayFire Documentation   Result:  actual type info (Boolean)  eval()   eval()   -  ArrayFire Documentation   Evaluate any JIT expressions to generate data for the array.", 
            "title": "Methods"
        }, 
        {
            "location": "/AFArray/#indexing-operations", 
            "text": "at()  -  ArrayFire Documentation   at(s0)  at(s0, s1)  at(s0, s1, s2)  at(s0, s1, s2, s3)  at(def)   Arguments :   s0 .. s3: null|String|Number| Seq |AFArray    null:  means  \"span\"  String:  can be  \"span\"  Number:  element's index, or -1 which means the last element  Seq :  sequence of values  AFArray:  array holding the index value    def :  Row | Rows | Col | Cols | Slice | Slices  Row : specified row  Rows : specified rows  Col : specified column  Cols : specified columns  Slice : specified slice  Slices : specified slices     Result:  AFArray instance holding reference to the the specified region of the original array  row(), rows()  Gets a reference of a row in a 2D AFArray.  -  ArrayFire Documentation   row(index)  rows(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a row index or a range of row indices   Result:  AFArray instance holding reference to the specified region of the original 2D array  col(), cols()  Gets a reference of a column in a 2D AFArray.  -  ArrayFire Documentation   col(index)  cols(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a column index or a range of column indices   Result:  AFArray instance holding reference to the specified region of the original 2D array  slice(), slices()  Gets a reference of a matrix in a 3D AFArray.  -  ArrayFire Documentation   slice(index)  slices(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a matrix index or a range of matrix indices   Result:  AFArray instance holding reference to the specified region of the original 3D array", 
            "title": "Indexing Operations"
        }, 
        {
            "location": "/AFArray/#assignment-operators", 
            "text": "-  ArrayFire Documentation   assign(other)  operator =  set(other)  operator = (alias of assign)  addAssign(other)  operator +=  subAssign(other)  operator -=  mulAssign(other)  operator *=  divAssign(other)  operator /=  assign(s0, other)  operator =  set(s0, other)  operator = (alias of assign)  addAssign(s0, other)  operator +=  subAssign(s0, other)  operator -=  mulAssign(s0, other)  operator *=  divAssign(s0, other)  operator /=  assign(s0, s1, other)  operator =  set(s0, s1, other)  operator = (alias of assign)  addAssign(s0, s1, other)  operator +=  subAssign(s0, s1, other)  operator -=  mulAssign(s0, s1, other)  operator *=  divAssign(s0, s1, other)  operator /=  assign(s0, s1, s2, other)  operator =  set(s0, s1, s2, other)  operator = (alias of assign)  addAssign(s0, s1, s2, other)  operator +=  subAssign(s0, s1, s2, other)  operator -=  mulAssign(s0, s1, s2, other)  operator *=  divAssign(s0, s1, s2, other)  operator /=  assign(s0, s1, s2, s3, other)  operator =  set(s0, s1, s2, s3, other)  operator = (alias of assign)  addAssign(s0, s1, s2, s3, other)  operator +=  subAssign(s0, s1, s2, s3, other)  operator -=  mulAssign(s0, s1, s2, s3, other)  operator *=  divAssign(s0, s1, s2, s3, other)  operator /=  assign(def, other)  operator =  set(def, other)  operator = (alias of assign)  addAssign(def, other)  operator +=  subAssign(def, other)  operator -=  mulAssign(def, other)  operator *=  divAssign(def, other)  operator /=   Arguments :   s0 .. s3: null|String|Number| Seq |AFArray  lhs index  null:  means  \"span\"  String:  can be  \"span\"  Number:  element's index, or -1 which means the last element  Seq :  sequence of values  AFArray:  array holding the index value    def :  Row | Rows | Col | Cols | Slice | Slices  Row : specified row  Rows : specified rows  Col : specified column  Cols : specified columns  Slice : specified slice  Slices : specified slices    other: AFArray|Number| Complex |String    AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  assignee AFArray instance", 
            "title": "Assignment Operators"
        }, 
        {
            "location": "/AFArray/#arithmetic-operators", 
            "text": "-  ArrayFire Documentation   add(other)  operator +  sub(other)  operator -  mul(other)  operator *  div(other)  operator /  bitshiftl(other)  operator   bitShiftL(other)  operator   (alias of bitshiftl)  bitshiftr(other)  operator   bitShiftR(other)  operator   (alias of bitshiftr)   Arguments :   other: AFArray|Number| Complex |String    AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  AFArray instance holding the operation's result", 
            "title": "Arithmetic Operators"
        }, 
        {
            "location": "/AFArray/#logical-operators", 
            "text": "-  ArrayFire Documentation   neg()  operator -  not()  operator !  lt(other)  operator   gt(other)  operator   le(other)  operator  =  ge(other)  operator  =  eq(other)  operator ==  neq(other)  operator !=  and(other)  operator   or(other)  operator ||  bitAnd(other)  operator   bitOr(other)  operator |  bitXor(other)  operator ^   Arguments :   other: AFArray|Number| Complex |String    AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  AFArray instance holding the operation's result", 
            "title": "Logical Operators"
        }, 
        {
            "location": "/Dim4/", 
            "text": "Dim4 class\n\n\nconstructors\n\n\n\n\nnew Dim4(dimArray)\n\n\nnew Dim4(dim0, dim1, dim2, dim3)\n\n\n\n\nArguments\n:\n\n\n\n\ndimArray: Array\n - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]\n\n\ndim0 .. dim3: Number\n - size of the dimension, default is 1\n\n\n\n\nProperties\n\n\nvalues\n\n\nValue:\n \nArray\n containing the dimension sizes, eg.: two dimensions = \n[2, 3, 1, 1]\n, four dimensions = \n[2, 3, 4, 5]\n\n\nndims\n\n\nalias: \nnDims\n\n\nValue:\n number of dimensions\n\n\nelements\n\n\nValue:\n number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Dim4"
        }, 
        {
            "location": "/Dim4/#dim4-class", 
            "text": "", 
            "title": "Dim4 class"
        }, 
        {
            "location": "/Dim4/#constructors", 
            "text": "new Dim4(dimArray)  new Dim4(dim0, dim1, dim2, dim3)   Arguments :   dimArray: Array  - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]  dim0 .. dim3: Number  - size of the dimension, default is 1", 
            "title": "constructors"
        }, 
        {
            "location": "/Dim4/#properties", 
            "text": "values  Value:   Array  containing the dimension sizes, eg.: two dimensions =  [2, 3, 1, 1] , four dimensions =  [2, 3, 4, 5]  ndims  alias:  nDims  Value:  number of dimensions  elements  Value:  number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Properties"
        }, 
        {
            "location": "/Seq/", 
            "text": "Seq class\n\n\nconstructors\n\n\n\n\nnew Seq(begin, end)\n\n\nnew Seq(begin, end, step)\n\n\n\n\nArguments\n:\n\n\n\n\nbegin: Number\n - begin of sequence values\n\n\nend: Number\n - end of sequence values\n\n\nstep: Number\n - step size (default is 1)\n\n\n\n\nProperties\n\n\nbegin\n\n\nValue:\n begin of sequence values\n\n\nend\n\n\nValue:\n end of sequence values\n\n\nstep\n\n\nValue:\n step size", 
            "title": "Seq"
        }, 
        {
            "location": "/Seq/#seq-class", 
            "text": "", 
            "title": "Seq class"
        }, 
        {
            "location": "/Seq/#constructors", 
            "text": "new Seq(begin, end)  new Seq(begin, end, step)   Arguments :   begin: Number  - begin of sequence values  end: Number  - end of sequence values  step: Number  - step size (default is 1)", 
            "title": "constructors"
        }, 
        {
            "location": "/Seq/#properties", 
            "text": "begin  Value:  begin of sequence values  end  Value:  end of sequence values  step  Value:  step size", 
            "title": "Properties"
        }, 
        {
            "location": "/Complex/", 
            "text": "Complex class\n\n\nconstructor\n\n\n\n\nnew Complex(real, imag)\n\n\n\n\nArguments\n:\n\n\n\n\nreal: Number\n - real part of the value\n\n\nimag: Number\n - imaginary part of the value\n\n\n\n\nProperties\n\n\nreal\n\n\nValue:\n real part of the value\n\n\nimag\n\n\nValue:\n imaginary part of the value", 
            "title": "Complex"
        }, 
        {
            "location": "/Complex/#complex-class", 
            "text": "", 
            "title": "Complex class"
        }, 
        {
            "location": "/Complex/#constructor", 
            "text": "new Complex(real, imag)   Arguments :   real: Number  - real part of the value  imag: Number  - imaginary part of the value", 
            "title": "constructor"
        }, 
        {
            "location": "/Complex/#properties", 
            "text": "real  Value:  real part of the value  imag  Value:  imaginary part of the value", 
            "title": "Properties"
        }, 
        {
            "location": "/Row/", 
            "text": "Row class\n\n\nconstructor\n\n\n\n\nnew Row(index)\n\n\n\n\nArguments\n:\n\n\n\n\nindex: Number\n - row index\n\n\n\n\nProperties\n\n\nindex\n\n\nValue:\n row index", 
            "title": "Row"
        }, 
        {
            "location": "/Row/#row-class", 
            "text": "", 
            "title": "Row class"
        }, 
        {
            "location": "/Row/#constructor", 
            "text": "new Row(index)   Arguments :   index: Number  - row index", 
            "title": "constructor"
        }, 
        {
            "location": "/Row/#properties", 
            "text": "index  Value:  row index", 
            "title": "Properties"
        }, 
        {
            "location": "/Rows/", 
            "text": "Rows class\n\n\nconstructor\n\n\n\n\nnew Rows(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nfirstIndex: Number\n - first row index\n\n\nlastIndex: Number\n - last row index\n\n\n\n\nProperties\n\n\nfirstIndex\n\n\nValue:\n first row index\n\n\nlastIndex\n\n\nValue:\n last row index", 
            "title": "Rows"
        }, 
        {
            "location": "/Rows/#rows-class", 
            "text": "", 
            "title": "Rows class"
        }, 
        {
            "location": "/Rows/#constructor", 
            "text": "new Rows(firstIndex, lastIndex)   Arguments :   firstIndex: Number  - first row index  lastIndex: Number  - last row index", 
            "title": "constructor"
        }, 
        {
            "location": "/Rows/#properties", 
            "text": "firstIndex  Value:  first row index  lastIndex  Value:  last row index", 
            "title": "Properties"
        }, 
        {
            "location": "/Col/", 
            "text": "Col class\n\n\nconstructor\n\n\n\n\nnew Col(index)\n\n\n\n\nArguments\n:\n\n\n\n\nindex: Number\n - column index\n\n\n\n\nProperties\n\n\nindex\n\n\nValue:\n column index", 
            "title": "Col"
        }, 
        {
            "location": "/Col/#col-class", 
            "text": "", 
            "title": "Col class"
        }, 
        {
            "location": "/Col/#constructor", 
            "text": "new Col(index)   Arguments :   index: Number  - column index", 
            "title": "constructor"
        }, 
        {
            "location": "/Col/#properties", 
            "text": "index  Value:  column index", 
            "title": "Properties"
        }, 
        {
            "location": "/Cols/", 
            "text": "Cols class\n\n\nconstructor\n\n\n\n\nnew Cols(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nfirstIndex: Number\n - first col index\n\n\nlastIndex: Number\n - last col index\n\n\n\n\nProperties\n\n\nfirstIndex\n\n\nValue:\n first col index\n\n\nlastIndex\n\n\nValue:\n last col index", 
            "title": "Cols"
        }, 
        {
            "location": "/Cols/#cols-class", 
            "text": "", 
            "title": "Cols class"
        }, 
        {
            "location": "/Cols/#constructor", 
            "text": "new Cols(firstIndex, lastIndex)   Arguments :   firstIndex: Number  - first col index  lastIndex: Number  - last col index", 
            "title": "constructor"
        }, 
        {
            "location": "/Cols/#properties", 
            "text": "firstIndex  Value:  first col index  lastIndex  Value:  last col index", 
            "title": "Properties"
        }, 
        {
            "location": "/Slice/", 
            "text": "Slice class\n\n\nconstructor\n\n\n\n\nnew Slice(index)\n\n\n\n\nArguments\n:\n\n\n\n\nindex: Number\n - slice index\n\n\n\n\nProperties\n\n\nindex\n\n\nValue:\n slice index", 
            "title": "Slice"
        }, 
        {
            "location": "/Slice/#slice-class", 
            "text": "", 
            "title": "Slice class"
        }, 
        {
            "location": "/Slice/#constructor", 
            "text": "new Slice(index)   Arguments :   index: Number  - slice index", 
            "title": "constructor"
        }, 
        {
            "location": "/Slice/#properties", 
            "text": "index  Value:  slice index", 
            "title": "Properties"
        }, 
        {
            "location": "/Slices/", 
            "text": "Slices class\n\n\nconstructor\n\n\n\n\nnew Slices(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nfirstIndex: Number\n - first slice index\n\n\nlastIndex: Number\n - last slice index\n\n\n\n\nProperties\n\n\nfirstIndex\n\n\nValue:\n first slice index\n\n\nlastIndex\n\n\nValue:\n last slice index", 
            "title": "Slices"
        }, 
        {
            "location": "/Slices/#slices-class", 
            "text": "", 
            "title": "Slices class"
        }, 
        {
            "location": "/Slices/#constructor", 
            "text": "new Slices(firstIndex, lastIndex)   Arguments :   firstIndex: Number  - first slice index  lastIndex: Number  - last slice index", 
            "title": "constructor"
        }, 
        {
            "location": "/Slices/#properties", 
            "text": "firstIndex  Value:  first slice index  lastIndex  Value:  last slice index", 
            "title": "Properties"
        }, 
        {
            "location": "/devices/", 
            "text": "Platform and Device managing\n\n\n-\n ArrayFire Documentation\n\n\n\n\n\n\n\n\n\n\nSelecting Platform\n\n\ngetDeviceCount()\n\n\ngetDevices()\n\n\ngetDevice()\n\n\nsetDevice()\n\n\ndeviceInfo()\n\n\nisDoubleAvailable()\n\n\nsync()\n\n\nwait()\n\n\nalloc()\n\n\npinned()\n\n\n\n\n\n\n\nSelecting Platform\n\n\nFire.js platform can be selected by calling the root function with the appropriate platform ID as an argument.\n\n\nSupported platform IDs:\n\n\n\n\nCPU\n (cpu fallback)\n\n\nOpenCL\n\n\nCUDA\n\n\n\n\nExample:\n\n\nvar af = require(\narrayfire-js\n);\nvar cpuPlatform = af(\nCPU\n);\n\n\n\n\ngetDeviceCount()\n\n\nGets the number of devices on the given platform.\n\n\n\n\ngetDeviceCount()\n: \n-\n ArrayFire Documentation\n\n\n\n\nResult: Number\n - number of devices\n\n\nExample:\n\n\nvar af = require(\narrayfire-js\n);\nvar cpuPlatform = af(\nCPU\n);\nvar deviceCount = cpuPlatform.getDeviceCount();\n\n\n\n\ngetDevices()\n\n\nGets available device descriptors on the given platform.\n\n\n\n\ngetDevices()\n\n\n\n\nResult: Array\n - array of \ndevice descriptors\n \n\n\ngetDevice()\n\n\nGet the current device ID. \n\n\n\n\ngetDevice()\n: \n-\n ArrayFire Documentation\n\n\n\n\nResult: Number\n - current device ID\n\n\nsetDevice()\n\n\nChange current device to specified device.\n\n\n\n\nsetDevice(id)\n: \n-\n ArrayFire Documentation\n \n\n\n\n\ndeviceInfo()\n\n\nGet the current device's descriptor. \n\n\n\n\ndeviceInfo()\n: \n-\n ArrayFire Documentation\n\n\n\n\nResult: object\n - fields\n\n\n\n\nname: String\n - device's vendor specified name\n\n\nplatform: String\n - ID of the platform (CPU, OpenCL, CUDA)\n\n\ntoolkit: String\n - device's vendor specified platform name\n\n\ncompute: String\n - device's vendor specified version\n\n\nisDoubleAvailable: Boolean\n - is double precision supported\n\n\n\n\nisDoubleAvailable()\n\n\nCheck if double precision support is available for specified device. \n\n\n\n\nisDoubleAvailable(deviceID)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArgments:\n\n\n\n\ndeviceID: Number\n - device's ID\n\n\n\n\nResult: Booean\n - is double precision supported\n\n\nsync()\n\n\nasynchronous, counterparts: \nsyncAsync\n, \nsyncSync\n\n\nWaits until all operations on device are finished. \n\n\n\n\nsync()\n: \n-\n ArrayFire Documentation\n\n\n\n\nwait()\n\n\nalias of \nsync()\n\n\nalloc()\n\n\nAllocates memory on the device.\n\n\n\n\nalloc(elements, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nelements: Number\n - number of elements to allocate\n\n\ntype: value of \ndType\n - type of the elements, can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult: Buffer\n - device memory pointer\n\n\nRemarks:\n Deallocation is handled by the GC automatically\n\n\npinned()\n\n\nAllocates pinned memory on the host by using ArrayFire's memory manager.\n\n\n\n\npinned(elements, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nelements: Number\n - number of elements to allocate\n\n\ntype: value of \ndType\n - type of the elements, can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult: Buffer\n - memory pointer\n\n\nRemarks:\n Deallocation is handled by the GC automatically", 
            "title": "Platform and Device managing"
        }, 
        {
            "location": "/devices/#platform-and-device-managing", 
            "text": "-  ArrayFire Documentation     Selecting Platform  getDeviceCount()  getDevices()  getDevice()  setDevice()  deviceInfo()  isDoubleAvailable()  sync()  wait()  alloc()  pinned()", 
            "title": "Platform and Device managing"
        }, 
        {
            "location": "/devices/#selecting-platform", 
            "text": "Fire.js platform can be selected by calling the root function with the appropriate platform ID as an argument.  Supported platform IDs:   CPU  (cpu fallback)  OpenCL  CUDA   Example:  var af = require( arrayfire-js );\nvar cpuPlatform = af( CPU );", 
            "title": "Selecting Platform"
        }, 
        {
            "location": "/devices/#getdevicecount", 
            "text": "Gets the number of devices on the given platform.   getDeviceCount() :  -  ArrayFire Documentation   Result: Number  - number of devices  Example:  var af = require( arrayfire-js );\nvar cpuPlatform = af( CPU );\nvar deviceCount = cpuPlatform.getDeviceCount();", 
            "title": "getDeviceCount()"
        }, 
        {
            "location": "/devices/#getdevices", 
            "text": "Gets available device descriptors on the given platform.   getDevices()   Result: Array  - array of  device descriptors", 
            "title": "getDevices()"
        }, 
        {
            "location": "/devices/#getdevice", 
            "text": "Get the current device ID.    getDevice() :  -  ArrayFire Documentation   Result: Number  - current device ID", 
            "title": "getDevice()"
        }, 
        {
            "location": "/devices/#setdevice", 
            "text": "Change current device to specified device.   setDevice(id) :  -  ArrayFire Documentation", 
            "title": "setDevice()"
        }, 
        {
            "location": "/devices/#deviceinfo", 
            "text": "Get the current device's descriptor.    deviceInfo() :  -  ArrayFire Documentation   Result: object  - fields   name: String  - device's vendor specified name  platform: String  - ID of the platform (CPU, OpenCL, CUDA)  toolkit: String  - device's vendor specified platform name  compute: String  - device's vendor specified version  isDoubleAvailable: Boolean  - is double precision supported", 
            "title": "deviceInfo()"
        }, 
        {
            "location": "/devices/#isdoubleavailable", 
            "text": "Check if double precision support is available for specified device.    isDoubleAvailable(deviceID) :  -  ArrayFire Documentation   Argments:   deviceID: Number  - device's ID   Result: Booean  - is double precision supported", 
            "title": "isDoubleAvailable()"
        }, 
        {
            "location": "/devices/#sync", 
            "text": "asynchronous, counterparts:  syncAsync ,  syncSync  Waits until all operations on device are finished.    sync() :  -  ArrayFire Documentation", 
            "title": "sync()"
        }, 
        {
            "location": "/devices/#wait", 
            "text": "alias of  sync()", 
            "title": "wait()"
        }, 
        {
            "location": "/devices/#alloc", 
            "text": "Allocates memory on the device.   alloc(elements, type) :  -  ArrayFire Documentation   Arguments:   elements: Number  - number of elements to allocate  type: value of  dType  - type of the elements, can be one of the values of dType object (eg.  dType.f32 )   Result: Buffer  - device memory pointer  Remarks:  Deallocation is handled by the GC automatically", 
            "title": "alloc()"
        }, 
        {
            "location": "/devices/#pinned", 
            "text": "Allocates pinned memory on the host by using ArrayFire's memory manager.   pinned(elements, type) :  -  ArrayFire Documentation   Arguments:   elements: Number  - number of elements to allocate  type: value of  dType  - type of the elements, can be one of the values of dType object (eg.  dType.f32 )   Result: Buffer  - memory pointer  Remarks:  Deallocation is handled by the GC automatically", 
            "title": "pinned()"
        }, 
        {
            "location": "/create/", 
            "text": "Functions to create arrays\n\n\n-\n ArrayFire Documentation\n\n\nTOC\n\n\n\n\n\n\n\n\n\n\nrandu()\n\n\nrandU()\n\n\nrandn()\n\n\nrandN()\n\n\nidentity()\n\n\nrange()\n\n\niota()\n\n\ndiag()\n\n\nconstant()\n\n\n\n\n\n\n\nrandu()\n\n\nCreate a random array sampled from uniform distribution.\n\n\n\n\nrandu(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nrandu(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nrandU()\n\n\nalias of \nrandu()\n\n\nrandn()\n\n\nCreate a random array sampled from normal distribution.\n\n\n\n\nrandn(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nrandn(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nrandN()\n\n\nalias of \nrandn()\n\n\nidentity()\n\n\nCreate an identity matrix (array with diagonal values 1).\n\n\n\n\nidentity(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nidentity(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nrange()\n\n\nCreates an array with [0, n] values along the seqDim which is tiled across other dimensions.\n\n\n\n\nrange(dim0, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dim0, dim1, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dim0, dim1, dim2, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dim0, dim1, dim2, dim3, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\nrange(dims, seqDim, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nseqDim: Number\n - dimension along which [0, dim[seqDim] - 1] is generated, default is -1, which means the last specified dimension \n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\niota()\n\n\nCreate an sequence [0, dims.elements - 1] and modify to specified dimensions dims and then tile it according to tileDims.\n\n\n\n\niota(dims, tileDims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\n\n\n\n\n- **dims: Array\n\n\nDim4\n** - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\n\n\n\n\n\n\n\n\n- \ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\n\n\n\n\n\n\nResult\n: the created AFArray instance.\n\n\ndiag()\n\n\nExtract diagonal from a matrix when \nextract\n is set to \ntrue\n. \n\n\nCreate a diagonal marix from input array when \nextract\n is set to \nfalse\n.\n\n\n\n\ndiag(in, num, extract)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nin: AFArray\n - input array\n\n\nnum: Number\n - diagonal index\n\n\nextract: Boolean\n - when true returns an array containing diagonal of tha matrix and when false returns a matrix with in as diagonal\n\n\n\n\nconstant()\n\n\nCreate an array filled with the specified value.\n\n\n\n\nconstant(value, dim0, type)\n\n\nconstant(value, dim0, dim1, type)\n\n\nconstant(value, dim0, dim1, dim2, type)\n\n\nconstant(value, dim0, dim1, dim2, dim3, type)\n\n\nconstant(value, dims, type)\n\n\n\n\nArguments:\n\n\n\n\nvalue: Number|\nComplex\n|String\n\n\nNumber:\n number\n\n\nComplex\n:\n complex value\n\n\nString:\n: number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimensions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nResult\n: the created AFArray instance.", 
            "title": "Functions to create arrays"
        }, 
        {
            "location": "/create/#functions-to-create-arrays", 
            "text": "-  ArrayFire Documentation", 
            "title": "Functions to create arrays"
        }, 
        {
            "location": "/create/#toc", 
            "text": "randu()  randU()  randn()  randN()  identity()  range()  iota()  diag()  constant()", 
            "title": "TOC"
        }, 
        {
            "location": "/create/#randu", 
            "text": "Create a random array sampled from uniform distribution.   randu(dim0, type) :  -  ArrayFire Documentation  randu(dim0, dim1, type) :  -  ArrayFire Documentation  randu(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  randu(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  randu(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "randu()"
        }, 
        {
            "location": "/create/#randu_1", 
            "text": "alias of  randu()", 
            "title": "randU()"
        }, 
        {
            "location": "/create/#randn", 
            "text": "Create a random array sampled from normal distribution.   randn(dim0, type) :  -  ArrayFire Documentation  randn(dim0, dim1, type) :  -  ArrayFire Documentation  randn(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  randn(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  randn(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "randn()"
        }, 
        {
            "location": "/create/#randn_1", 
            "text": "alias of  randn()", 
            "title": "randN()"
        }, 
        {
            "location": "/create/#identity", 
            "text": "Create an identity matrix (array with diagonal values 1).   identity(dim0, type) :  -  ArrayFire Documentation  identity(dim0, dim1, type) :  -  ArrayFire Documentation  identity(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  identity(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  identity(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "identity()"
        }, 
        {
            "location": "/create/#range", 
            "text": "Creates an array with [0, n] values along the seqDim which is tiled across other dimensions.   range(dim0, seqDim, type) :  -  ArrayFire Documentation  range(dim0, dim1, seqDim, type) :  -  ArrayFire Documentation  range(dim0, dim1, dim2, seqDim, type) :  -  ArrayFire Documentation  range(dim0, dim1, dim2, dim3, seqDim, type) :  -  ArrayFire Documentation  range(dims, seqDim, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  seqDim: Number  - dimension along which [0, dim[seqDim] - 1] is generated, default is -1, which means the last specified dimension   type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "range()"
        }, 
        {
            "location": "/create/#iota", 
            "text": "Create an sequence [0, dims.elements - 1] and modify to specified dimensions dims and then tile it according to tileDims.   iota(dims, tileDims, type) :  -  ArrayFire Documentation   Arguments:     - **dims: Array  Dim4 ** - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)      -  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )      Result : the created AFArray instance.", 
            "title": "iota()"
        }, 
        {
            "location": "/create/#diag", 
            "text": "Extract diagonal from a matrix when  extract  is set to  true .   Create a diagonal marix from input array when  extract  is set to  false .   diag(in, num, extract) :  -  ArrayFire Documentation   Arguments:   in: AFArray  - input array  num: Number  - diagonal index  extract: Boolean  - when true returns an array containing diagonal of tha matrix and when false returns a matrix with in as diagonal", 
            "title": "diag()"
        }, 
        {
            "location": "/create/#constant", 
            "text": "Create an array filled with the specified value.   constant(value, dim0, type)  constant(value, dim0, dim1, type)  constant(value, dim0, dim1, dim2, type)  constant(value, dim0, dim1, dim2, dim3, type)  constant(value, dims, type)   Arguments:   value: Number| Complex |String  Number:  number  Complex :  complex value  String: : number value (to workaround JavaScript inability to hold int64 values)    dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimensions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Result : the created AFArray instance.", 
            "title": "constant()"
        }, 
        {
            "location": "/helpers/", 
            "text": "Helper function for arrays\n\n\n-\n ArrayFire Documentation\n\n\nTOC\n\n\n\n\n\n\n\n\n\n\niszero()\n\n\nisZero()\n\n\nisInf()\n\n\nisNaN()\n\n\n\n\n\n\n\niszero()\n\n\nCheck if values are zero. \n\n\n\n\niszero()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult: AFArray:\n containing 1's where input is zero, and 0 otherwise.\n\n\nisZero()\n\n\nalias of \niszero()\n\n\nisInf()\n\n\nCheck if values are infinite. \n\n\n\n\nisInf()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult: AFArray:\n containing 1's where input is infinity, and 0 otherwise.\n\n\nisNaN()\n\n\nCheck if values are Nan. \n\n\n\n\nisNaN()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult: AFArray:\n containing 1's where input is NaN, and 0 otherwise.", 
            "title": "Helper function for arrays"
        }, 
        {
            "location": "/helpers/#helper-function-for-arrays", 
            "text": "-  ArrayFire Documentation", 
            "title": "Helper function for arrays"
        }, 
        {
            "location": "/helpers/#toc", 
            "text": "iszero()  isZero()  isInf()  isNaN()", 
            "title": "TOC"
        }, 
        {
            "location": "/helpers/#iszero", 
            "text": "Check if values are zero.    iszero()   -  ArrayFire Documentation   Result: AFArray:  containing 1's where input is zero, and 0 otherwise.", 
            "title": "iszero()"
        }, 
        {
            "location": "/helpers/#iszero_1", 
            "text": "alias of  iszero()", 
            "title": "isZero()"
        }, 
        {
            "location": "/helpers/#isinf", 
            "text": "Check if values are infinite.    isInf()   -  ArrayFire Documentation   Result: AFArray:  containing 1's where input is infinity, and 0 otherwise.", 
            "title": "isInf()"
        }, 
        {
            "location": "/helpers/#isnan", 
            "text": "Check if values are Nan.    isNaN()   -  ArrayFire Documentation   Result: AFArray:  containing 1's where input is NaN, and 0 otherwise.", 
            "title": "isNaN()"
        }, 
        {
            "location": "/enums/", 
            "text": "Static Objects\n\n\nThey are accessible from the main Fire.js context object, eg.:\n\n\nvar af = require(\narrayfire-js\n)(\nCPU\n);\n\n// dType:\nvar dType = af.dType;\n\n\n\n\nTOC\n\n\n\n\n\n\n\n\n\n\ndType\n\n\nsource\n\n\nmatchType\n\n\nborderType\n\n\nconnectivity\n\n\nconvDomain\n\n\nconvMode\n\n\ncSpace\n\n\ninterpType\n\n\nmatProp\n\n\nnormType\n\n\n\n\n\n\n\ndType\n\n\nalias: \ndtype\n\n\n{\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}\n\n\n\n\nsource\n\n\n{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}\n\n\n\n\nmatchType\n\n\n{\n    SAD: 0,     // Match based on Sum of Absolute Differences (SAD)\n    zSAD: 1,    // Match based on Zero mean SAD.\n    lSAD: 2,    // Match based on Locally scaled SAD.\n    SSD: 3,     // Match based on Sum of Squared Differences (SSD)\n    zSSD: 4,    // Match based on Zero mean SSD.\n    lSSD: 5,    // Match based on Locally scaled SSD.\n    NCC: 6,     // Match based on Normalized Cross Correlation (NCC)\n    zNCC: 7,    // Match based on Zero mean NCC.\n    SHD: 8,     // Match based on Sum of Hamming Distances (SHD)\n    // ArrayFire convention compatible aliases:\n    AF_SAD: 0,\n    AF_ZSAD: 1,\n    AF_LSAD: 2,\n    AF_SSD: 3,\n    AF_ZSSD: 4,\n    AF_LSSD: 5,\n    AF_NCC: 6,\n    AF_ZNCC: 7,\n    AF_SHD: 8\n}\n\n\n\n\nborderType\n\n\n{\n    padZero: 0,\n    padSym: 1,\n    // ArrayFire convention compatible aliases:\n    AF_PAD_ZERO: 0,\n    AF_PAD_SYM: 1\n}\n\n\n\n\nconnectivity\n\n\n{\n    connectivity4: 4,\n    connectivity8: 8,\n    // ArrayFire convention compatible aliases:\n    AF_CONNECTIVITY_4: 4,\n    AF_CONNECTIVITY_8: 8\n}\n\n\n\n\nconvDomain\n\n\n{\n    auto: 0,    ///\n ArrayFire automatically picks the right convolution algorithm\n    spatial: 1, ///\n Perform convolution in spatial domain\n    freq: 2,   ///\n Perform convolution in frequency domain\n    // ArrayFire convention compatible aliases:\n    AF_CONV_AUTO: 0,    ///\n ArrayFire automatically picks the right convolution algorithm\n    AF_CONV_SPATIAL: 1, ///\n Perform convolution in spatial domain\n    AF_CONV_FREQ: 2   ///\n Perform convolution in frequency domain\n}\n\n\n\n\nconvMode\n\n\n{\n    ///\n    /// Output of the convolution is the same size as input\n    ///\n    default: 0,\n    ///\n    /// Output of the convolution is signal_len + filter_len - 1\n    ///\n    expand: 1,\n    // ArrayFire convention compatible aliases:\n    AF_CONV_DEFAULT: 0,\n    AF_CONV_EXPAND: 1\n}\n\n\n\n\ncSpace\n\n\n{\n    Gray: 0, ///\n Grayscale\n    RGB: 1,      ///\n 3-channel RGB\n    HSV: 2,       ///\n 3-channel HSV\n    // ArrayFire convention compatible aliases:\n    AF_GRAY: 0, ///\n Grayscale\n    AF_RGB: 1,      ///\n 3-channel RGB\n    AF_HSV: 2       ///\n 3-channel HSV\n}\n\n\n\n\ninterpType\n\n\n{\n    nearest: 0,  ///\n Nearest Interpolation\n    linear: 1,   ///\n Linear Interpolation\n    bilinerar : 2, ///\n Bilinear Interpolation\n    cubic: 3,    ///\n Cubic Interpolation,\n    // ArrayFire convention compatible aliases:\n    AF_INTERP_NEAREST: 0,  ///\n Nearest Interpolation\n    AF_INTERP_LINEAR: 1,   ///\n Linear Interpolation\n    AF_INTERP_BILINEAR : 2, ///\n Bilinear Interpolation\n    AF_INTERP_CUBIC: 3     ///\n Cubic Interpolation\n}\n\n\n\n\nmatProp\n\n\n{\n    none       : 0,    ///\n Default\n    trans      : 1,    ///\n Data needs to be transposed\n    cTrans     : 2,    ///\n Data needs to be conjugate tansposed\n    upper      : 32,   ///\n Matrix is upper triangular\n    lower      : 64,   ///\n Matrix is lower triangular\n    diagUnit   : 128,  ///\n Matrix diagonal contains unitary values\n    sym        : 512,  ///\n Matrix is symmetric\n    posDef     : 1024, ///\n Matrix is positive definite\n    orthog     : 2048, ///\n Matrix is orthogonal\n    triDiag    : 4096, ///\n Matrix is tri diagonal\n    blockDiag  : 8192,  ///\n Matrix is block diagonal\n    // ArrayFire convention compatible aliases:\n    AF_MAT_NONE       : 0,    ///\n Default\n    AF_MAT_TRANS      : 1,    ///\n Data needs to be transposed\n    AF_MAT_CTRANS     : 2,    ///\n Data needs to be conjugate tansposed\n    AF_MAT_UPPER      : 32,   ///\n Matrix is upper triangular\n    AF_MAT_LOWER      : 64,   ///\n Matrix is lower triangular\n    AF_MAT_DIAG_UNIT  : 128,  ///\n Matrix diagonal contains unitary values\n    AF_MAT_SYM        : 512,  ///\n Matrix is symmetric\n    AF_MAT_POSDEF     : 1024, ///\n Matrix is positive definite\n    AF_MAT_ORTHOG     : 2048, ///\n Matrix is orthogonal\n    AF_MAT_TRI_DIAG   : 4096, ///\n Matrix is tri diagonal\n    AF_MAT_BLOCK_DIAG : 8192  ///\n Matrix is block diagonal\n}\n\n\n\n\nnormType\n\n\n{\n    nearest: 0,  ///\n Nearest Interpolation\n    linear: 1,   ///\n Linear Interpolation\n    bilinerar : 2, ///\n Bilinear Interpolation\n    cubic: 3,    ///\n Cubic Interpolation,\n    // ArrayFire convention compatible aliases:\n    AF_INTERP_NEAREST: 0,  ///\n Nearest Interpolation\n    AF_INTERP_LINEAR: 1,   ///\n Linear Interpolation\n    AF_INTERP_BILINEAR : 2, ///\n Bilinear Interpolation\n    AF_INTERP_CUBIC: 3     ///\n Cubic Interpolation\n}", 
            "title": "Enums"
        }, 
        {
            "location": "/enums/#static-objects", 
            "text": "They are accessible from the main Fire.js context object, eg.:  var af = require( arrayfire-js )( CPU );\n\n// dType:\nvar dType = af.dType;", 
            "title": "Static Objects"
        }, 
        {
            "location": "/enums/#toc", 
            "text": "dType  source  matchType  borderType  connectivity  convDomain  convMode  cSpace  interpType  matProp  normType", 
            "title": "TOC"
        }, 
        {
            "location": "/enums/#dtype", 
            "text": "alias:  dtype  {\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}", 
            "title": "dType"
        }, 
        {
            "location": "/enums/#source", 
            "text": "{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}", 
            "title": "source"
        }, 
        {
            "location": "/enums/#matchtype", 
            "text": "{\n    SAD: 0,     // Match based on Sum of Absolute Differences (SAD)\n    zSAD: 1,    // Match based on Zero mean SAD.\n    lSAD: 2,    // Match based on Locally scaled SAD.\n    SSD: 3,     // Match based on Sum of Squared Differences (SSD)\n    zSSD: 4,    // Match based on Zero mean SSD.\n    lSSD: 5,    // Match based on Locally scaled SSD.\n    NCC: 6,     // Match based on Normalized Cross Correlation (NCC)\n    zNCC: 7,    // Match based on Zero mean NCC.\n    SHD: 8,     // Match based on Sum of Hamming Distances (SHD)\n    // ArrayFire convention compatible aliases:\n    AF_SAD: 0,\n    AF_ZSAD: 1,\n    AF_LSAD: 2,\n    AF_SSD: 3,\n    AF_ZSSD: 4,\n    AF_LSSD: 5,\n    AF_NCC: 6,\n    AF_ZNCC: 7,\n    AF_SHD: 8\n}", 
            "title": "matchType"
        }, 
        {
            "location": "/enums/#bordertype", 
            "text": "{\n    padZero: 0,\n    padSym: 1,\n    // ArrayFire convention compatible aliases:\n    AF_PAD_ZERO: 0,\n    AF_PAD_SYM: 1\n}", 
            "title": "borderType"
        }, 
        {
            "location": "/enums/#connectivity", 
            "text": "{\n    connectivity4: 4,\n    connectivity8: 8,\n    // ArrayFire convention compatible aliases:\n    AF_CONNECTIVITY_4: 4,\n    AF_CONNECTIVITY_8: 8\n}", 
            "title": "connectivity"
        }, 
        {
            "location": "/enums/#convdomain", 
            "text": "{\n    auto: 0,    ///  ArrayFire automatically picks the right convolution algorithm\n    spatial: 1, ///  Perform convolution in spatial domain\n    freq: 2,   ///  Perform convolution in frequency domain\n    // ArrayFire convention compatible aliases:\n    AF_CONV_AUTO: 0,    ///  ArrayFire automatically picks the right convolution algorithm\n    AF_CONV_SPATIAL: 1, ///  Perform convolution in spatial domain\n    AF_CONV_FREQ: 2   ///  Perform convolution in frequency domain\n}", 
            "title": "convDomain"
        }, 
        {
            "location": "/enums/#convmode", 
            "text": "{\n    ///\n    /// Output of the convolution is the same size as input\n    ///\n    default: 0,\n    ///\n    /// Output of the convolution is signal_len + filter_len - 1\n    ///\n    expand: 1,\n    // ArrayFire convention compatible aliases:\n    AF_CONV_DEFAULT: 0,\n    AF_CONV_EXPAND: 1\n}", 
            "title": "convMode"
        }, 
        {
            "location": "/enums/#cspace", 
            "text": "{\n    Gray: 0, ///  Grayscale\n    RGB: 1,      ///  3-channel RGB\n    HSV: 2,       ///  3-channel HSV\n    // ArrayFire convention compatible aliases:\n    AF_GRAY: 0, ///  Grayscale\n    AF_RGB: 1,      ///  3-channel RGB\n    AF_HSV: 2       ///  3-channel HSV\n}", 
            "title": "cSpace"
        }, 
        {
            "location": "/enums/#interptype", 
            "text": "{\n    nearest: 0,  ///  Nearest Interpolation\n    linear: 1,   ///  Linear Interpolation\n    bilinerar : 2, ///  Bilinear Interpolation\n    cubic: 3,    ///  Cubic Interpolation,\n    // ArrayFire convention compatible aliases:\n    AF_INTERP_NEAREST: 0,  ///  Nearest Interpolation\n    AF_INTERP_LINEAR: 1,   ///  Linear Interpolation\n    AF_INTERP_BILINEAR : 2, ///  Bilinear Interpolation\n    AF_INTERP_CUBIC: 3     ///  Cubic Interpolation\n}", 
            "title": "interpType"
        }, 
        {
            "location": "/enums/#matprop", 
            "text": "{\n    none       : 0,    ///  Default\n    trans      : 1,    ///  Data needs to be transposed\n    cTrans     : 2,    ///  Data needs to be conjugate tansposed\n    upper      : 32,   ///  Matrix is upper triangular\n    lower      : 64,   ///  Matrix is lower triangular\n    diagUnit   : 128,  ///  Matrix diagonal contains unitary values\n    sym        : 512,  ///  Matrix is symmetric\n    posDef     : 1024, ///  Matrix is positive definite\n    orthog     : 2048, ///  Matrix is orthogonal\n    triDiag    : 4096, ///  Matrix is tri diagonal\n    blockDiag  : 8192,  ///  Matrix is block diagonal\n    // ArrayFire convention compatible aliases:\n    AF_MAT_NONE       : 0,    ///  Default\n    AF_MAT_TRANS      : 1,    ///  Data needs to be transposed\n    AF_MAT_CTRANS     : 2,    ///  Data needs to be conjugate tansposed\n    AF_MAT_UPPER      : 32,   ///  Matrix is upper triangular\n    AF_MAT_LOWER      : 64,   ///  Matrix is lower triangular\n    AF_MAT_DIAG_UNIT  : 128,  ///  Matrix diagonal contains unitary values\n    AF_MAT_SYM        : 512,  ///  Matrix is symmetric\n    AF_MAT_POSDEF     : 1024, ///  Matrix is positive definite\n    AF_MAT_ORTHOG     : 2048, ///  Matrix is orthogonal\n    AF_MAT_TRI_DIAG   : 4096, ///  Matrix is tri diagonal\n    AF_MAT_BLOCK_DIAG : 8192  ///  Matrix is block diagonal\n}", 
            "title": "matProp"
        }, 
        {
            "location": "/enums/#normtype", 
            "text": "{\n    nearest: 0,  ///  Nearest Interpolation\n    linear: 1,   ///  Linear Interpolation\n    bilinerar : 2, ///  Bilinear Interpolation\n    cubic: 3,    ///  Cubic Interpolation,\n    // ArrayFire convention compatible aliases:\n    AF_INTERP_NEAREST: 0,  ///  Nearest Interpolation\n    AF_INTERP_LINEAR: 1,   ///  Linear Interpolation\n    AF_INTERP_BILINEAR : 2, ///  Bilinear Interpolation\n    AF_INTERP_CUBIC: 3     ///  Cubic Interpolation\n}", 
            "title": "normType"
        }
    ]
}