{
    "docs": [
        {
            "location": "/", 
            "text": "About ArrayFire\n\n\n\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"\n\n\nYou can read its introduction \nint its documentation's index page\n. It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just \nawesome\n. It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.\n\n\nAbout Fire.js\n\n\nFire.js is the Node.js bindings for ArrayFire, it uses \nCMake.js\n as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).\n\n\nInstall instructions can be found in the \nproject's readme at Github\n.\n\n\n(How To) Use ES6 Generators\n\n\nThe original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:\n\n\nfire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});\n\n\n\n\nYeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous Fire.js method has two counterparts. One synchronous, ends with \n\"Sync\"\n (eg. \nsqrtSync\n). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a \nBluebird promise\n, ends with \n\"Async\"\n (eg. \nsqrtAsync\n). Wrap an \nES6 generator function\n by a \ncoroutine\n, and you can yield those promises from there:\n\n\nlet async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});\n\n\n\n\nAnd voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those \nasync/await features\n that C# guys have! (Of course you can use some other coroutine library, like \nco\n.)\n\n\nTo run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.\n\n\nEven you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses \nGulp/Traceur\n and \nfeature detection\n to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.\n\n\nAPI\n\n\nIn Fire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.\n\n\nAll asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with \nAsync\n and \nSync\n endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.\n\n\nSmall Example\n\n\nPort of the PI calculator from \nArrayFire documentation\n:\n\n\nC++\n\n\n// sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum\nfloat\n(dist \n 1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);\n\n\n\n\nJavaScript\n\n\nconst numberOfPoints = 20000000;\n\n// ...\n\nlet x = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet y = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet dist = yield fire.sqrtAsync((x.mul(x)).add(y.mul(y)));\nlet num_inside = yield fire.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  num_inside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);\n\n\n\n\nIt's included in the \nexamples folder\n. To run on:\n\n\n\n\nio.js, enter: \niojs examples/es6/bechmarks/pi.js\n\n\nNode.js 0.12 or above, enter: \nnode --harmony examples/es6/bechmarks/pi.js\n\n\nNode.js below 0.12, enter: \nnode examples/es5/bechmarks/pi.js\n\n\n\n\nLicense\n\n\nApache 2.0\n\n\nCopyright 2015 G\u00e1bor Mez\u0151 aka unbornchikken (gabor.mezo@outlook.com)\n\nLicensed under the Apache License, Version 2.0 (the \nLicense\n);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \nAS IS\n BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-arrayfire", 
            "text": "\"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming more accessible.\"  You can read its introduction  int its documentation's index page . It's basically a math accelerator C++ library supporting CPU and GPU based backends on Windows, Linux and Mac. And it's just  awesome . It's extremely simple to write the most complex mathematical, statistical, logical computations, image transformations and computer vision algorigthms with it, just a few lines of code. It has excellent batching capability that takes simple operations, make a big computation from them, and runs all at once on the GPU device.", 
            "title": "About ArrayFire"
        }, 
        {
            "location": "/#about-firejs", 
            "text": "Fire.js is the Node.js bindings for ArrayFire, it uses  CMake.js  as of its build system. It takes Node.js' insane level of productivity and mix that with ArrayFire's insane level of performance and simplicity. You'll get something like Matlab just in familiar JavaScript with performance of level of x100 (with a good GPU).  Install instructions can be found in the  project's readme at Github .", 
            "title": "About Fire.js"
        }, 
        {
            "location": "/#how-to-use-es6-generators", 
            "text": "The original ArrayFire library contains a lot of functions that blocks. They are often run at O(n) atleast on CPU backend, or do some blocking initialization work on first call on OpenCL/CUDA platforms. Because of this those functions are wrapped asynchronously, and can be called with traditional Node.js callbacks, eg.:  fire.srqt(input, function(err, output) {\n    if (err) {\n        // crash :)\n    }\n    else {\n        // continue work ..\n    }\n});  Yeah, this is annoying and ugly compared to the original (blocking) C++ code. The good news is that can be improved by using ES6 generators. Each asynchronous Fire.js method has two counterparts. One synchronous, ends with  \"Sync\"  (eg.  sqrtSync ). Those are just for supporting REPL prototyping scenarios, not intended to use in production code, because those blocks the event loop and uses spin locks. The other is an asynchronous version that returns a  Bluebird promise , ends with  \"Async\"  (eg.  sqrtAsync ). Wrap an  ES6 generator function  by a  coroutine , and you can yield those promises from there:  let async = Bluebird.coroutine;\n\nlet f = async(function*() {\n    let values = yield fire.sqrtAsync(input);\n    let output = yield fire.sqrtAsync(input);\n});  And voila, you can write asynchronous code that looks like synchronous. It's exactly the same thing those  async/await features  that C# guys have! (Of course you can use some other coroutine library, like  co .)  To run ES6 code you can use io.js that supports it inherently. Or use Node.js 0.12+ with --harmony flag. Or you can go with older Node.js versions with Gulp and Traceur modules.  Even you can use feature detection and can write code that can run on each platform choosing ES5 or ES6 code paths depending of the actual runtime. Fire.js uses that method too. It has been developed in ES6, and uses  Gulp/Traceur  and  feature detection  to fallback to manually compiled ES5 code on older runtimes. If you need further information about this topic, please open up an issue on Github, and I'll help you out with this there.", 
            "title": "(How To) Use ES6 Generators"
        }, 
        {
            "location": "/#api", 
            "text": "In Fire.js all ArrayFire types and functions are ported with respect of the original C++ syntax. There are some exceptions when it was neccessary. Many methods have an alias to provide them a counterpart using Node.js (camelCased) conventions.  All asynchronous methods have promise based and synhronous counterparts as mentioned in the previous topic with  Async  and  Sync  endings rescpectively. This methods have the same signature like the originals, except the callback at the last argument.", 
            "title": "API"
        }, 
        {
            "location": "/#small-example", 
            "text": "Port of the PI calculator from  ArrayFire documentation :  C++  // sample 40 million points on the GPU\narray x = randu(20e6), y = randu(20e6);\narray dist = sqrt(x * x + y * y);\n\n// pi is ratio of how many fell in the unit circle\nfloat num_inside = sum float (dist   1);\nfloat pi = 4.0 * num_inside / 20e6;\naf_print(pi);  JavaScript  const numberOfPoints = 20000000;\n\n// ...\n\nlet x = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet y = yield fire.randuAsync(numberOfPoints, fire.types.dtype.f32);\nlet dist = yield fire.sqrtAsync((x.mul(x)).add(y.mul(y)));\nlet num_inside = yield fire.sumAsync(dist.lt(1));\nlet piVal = (4.0 *  num_inside) / numberOfPoints;\n\nconsole.log(`PI = ${piVal}`);  It's included in the  examples folder . To run on:   io.js, enter:  iojs examples/es6/bechmarks/pi.js  Node.js 0.12 or above, enter:  node --harmony examples/es6/bechmarks/pi.js  Node.js below 0.12, enter:  node examples/es5/bechmarks/pi.js", 
            "title": "Small Example"
        }, 
        {
            "location": "/#license", 
            "text": "Apache 2.0  Copyright 2015 G\u00e1bor Mez\u0151 aka unbornchikken (gabor.mezo@outlook.com)\n\nLicensed under the Apache License, Version 2.0 (the  License );\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an  AS IS  BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/statics/", 
            "text": "Static Objects\n\n\nThey are accessible from the main Fire.js context object, eg.:\n\n\nvar fire = require(\nfire-js\n)(\nCPU\n);\n\n// dType:\nvar dType = fire.types.dType;\n\n\n\n\ntypes.dType\n\n\nalias: \ntypes.dtype\n\n\n{\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}\n\n\n\n\ntypes.source\n\n\n{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}", 
            "title": "Statics"
        }, 
        {
            "location": "/statics/#static-objects", 
            "text": "They are accessible from the main Fire.js context object, eg.:  var fire = require( fire-js )( CPU );\n\n// dType:\nvar dType = fire.types.dType;", 
            "title": "Static Objects"
        }, 
        {
            "location": "/statics/#typesdtype", 
            "text": "alias:  types.dtype  {\n    f32: 0, // float\n    c32: 1, // complex of float\n    f64: 2, // double\n    c64: 3, // complex of double\n    b8: 4, // boolean (8 bits)\n    s32: 5, // int\n    u32: 6, // uint\n    u8: 7, // byte\n    s64: 8, // int64    \n    u64: 9 // uint64\n}", 
            "title": "types.dType"
        }, 
        {
            "location": "/statics/#typessource", 
            "text": "{\n    device: 0,\n    host: 1,\n    // ArrayFire convention compatible aliases:\n    afDevice: 0,  \n    afHost: 1\n}", 
            "title": "types.source"
        }, 
        {
            "location": "/AFArray/", 
            "text": "AFArray class\n\n\nStaitc methods\n\n\nAFArray.create()\n\n\nasynchronous, counterparts: \ncreateAsync\n, \ncreateSync\n\n\nCreates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the \nsource\n argument specifies its location.\n\n\n\n\ncreate(dim0, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, dim3, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dim0, dim1, dim2, dim4, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\ncreate(dims, buffer, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimentsions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\nResult\n: the created AFArray instance.\n\n\nconstructor\n\n\nArrays could be created as empty ones or by having a specified dimensions and element type. \n\n\n\n\nnew AFArray()\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dim0, dim1, dim2, dim3, type)\n: \n-\n ArrayFire Documentation\n\n\nnew AFArray(dims, type)\n: \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\ndim0 .. dim3: Number\n - size of the dimension\n\n\ndims: Array|\nDim4\n - specifies sizes of the dimentsions, eg: \n[2, 1, 1]\n or \nnew Dim4(3, 4)\n\n\nbuffer: Buffer\n - data to copy to the device, or device pointer created by the \nalloc\n method.\n\n\ntype: value of \ndType\n - can be one of the values of dType object (eg. \ndType.f32\n)\n\n\n\n\nRemarks:\n\n\nIn Fire.js \ntype\n argument is \nnot optional\n.\n\n\nMethods\n\n\nelements()\n\n\nGet the number of elements in array.\n\n\n\n\nelements()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n Number\n\n\nhost()\n\n\nCopy array data to host.\n\n\nasynchronous, counterparts: \nhostAsync\n, \nhostSync\n\n\n\n\nhost(callback)\n \n-\n ArrayFire Documentation\n\n\nhost(buffer, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - to hold array's values, must be atleast the size of the array.\n\n\n\n\nResult:\n if buffer is not specified, then it will be created and returned, otherwise the result is \nundefined\n\n\ncopyToHost()\n\n\nalias of \nhost\n\n\nwrite\n\n\nPerform deep copy from host/device pointer to an existing array.\n\n\n\n\nwrite(buffer, bytesToCopy, source, callback)\n \n-\n ArrayFire Documentation\n\n\n\n\nArguments:\n\n\n\n\nbuffer: Buffer\n - data to copy to the array, or device pointer created by the \nalloc\n method.\n\n\nbytesToCopy\n: bytes to copy\n\n\nsource: value of \nsource\n - can be one of the values of source object (eg. \nsource.host\n)\n\n\n\n\ntype\n\n\n\n\ntype()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's element type, can be one of the values of \ndType\n object\n\n\ndims\n\n\n\n\ndims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n array's dimensions info in a \nDim4\n object instance\n\n\nnumdims\n\n\n\n\nnumdims()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n number of dimensions of the array\n\n\nnumDims\n\n\nalias of \nnumdims\n\n\nbytes\n\n\n\n\nbytes()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n size of the array in bytes\n\n\ncopy\n\n\n\n\ncopy()\n \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n new AFArray instance holding a deep copy of the array\n\n\nisempty, isscalar, isvector, isrow, iscolumn, iscomplex, isreal, isdouble, issingle, isrealfloating, isfloating, isinteger, isbool\n\n\naliases respectively: \nisEmpty\n, \nisScalar\n, \nisVector\n, \nisRow\n, \nisColumn\n, \nisComplex\n, \nisReal\n, \nisDouble\n, \nisSingle\n, \nisRealFloating\n, \nisFloating\n, \nisInteger\n, \nisBool\n \n\n\n\n\nis\nanything\n() \n-\n ArrayFire Documentation\n\n\n\n\nResult:\n actual type info (Boolean)\n\n\neval\n\n\n\n\neval()\n \n-\n ArrayFire Documentation\n\n\n\n\nEvaluate any JIT expressions to generate data for the array.\n\n\nIndexing Operations\n\n\nat\n\n\n-\n ArrayFire Documentation\n\n\n\n\nat(s0)\n\n\nat(s0, s1)\n\n\nat(s0, s1, s2)\n\n\nat(s0, s1, s2, s3)\n\n\n\n\nArguments\n:\n\n\n\n\n\n\ns0 .. s3: null|String|Number|\nSeq\n|AFArray\n \n\n\n\n\nnull:\n means \n\"span\"\n\n\nString:\n can be \n\"span\"\n\n\nNumber:\n element's index, or -1 which means the last element\n\n\nSeq\n:\n sequence of values\n\n\nAFArray:\n array holding the index value\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding reference to the the specified region of the original array\n\n\nrow, rows\n\n\nGets a reference of a row in a 2D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\nrow(index)\n\n\nrows(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a row index or a range of row indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 2D array\n\n\ncol, cols\n\n\nGets a reference of a column in a 2D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\ncol(index)\n\n\ncols(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a column index or a range of column indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 2D array\n\n\nslice, slices\n\n\nGets a reference of a matrix in a 3D AFArray.\n\n\n-\n ArrayFire Documentation\n\n\n\n\nslice(index)\n\n\nslices(firstIndex, lastIndex)\n\n\n\n\nArguments\n:\n\n\n\n\nindex, fistIndex, lastIndex: Number\n - a matrix index or a range of matrix indices\n\n\n\n\nResult:\n AFArray instance holding reference to the specified region of the original 3D array\n\n\nOperators\n\n\nAssignment Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nassign(other)\n operator =\n\n\nset(other)\n operator = (alias of assign)\n\n\naddAssign(other)\n operator +=\n\n\nsubAssign(other)\n operator -=\n\n\nmulAssign(other)\n operator *=\n\n\ndivAssign(other)\n operator /=\n\n\n\n\nArguments\n:\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n assignee AFArray instance\n\n\nArithmetic Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nadd(other)\n operator +\n\n\nsub(other)\n operator -\n\n\nmul(other)\n operator *\n\n\ndiv(other)\n operator /\n\n\nbitshiftl(other)\n operator \n\n\nbitShiftL(other)\n operator \n (alias of bitshiftl)\n\n\nbitshiftr(other)\n operator \n\n\nbitShiftR(other)\n operator \n (alias of bitshiftr)\n\n\n\n\nArguments\n:\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding the operation's result\n\n\nLogical Operators\n\n\n-\n ArrayFire Documentation\n\n\n\n\nneg()\n operator -\n\n\nnot()\n operator !\n\n\nlt(other)\n operator \n\n\ngt(other)\n operator \n\n\nle(other)\n operator \n=\n\n\nge(other)\n operator \n=\n\n\neq(other)\n operator ==\n\n\nneq(other)\n operator !=\n\n\nand(other)\n operator \n\n\nor(other)\n operator ||\n\n\nbitAnd(other)\n operator \n\n\nbitOr(other)\n operator |\n\n\nbitXor(other)\n operator ^\n\n\n\n\nArguments\n:\n\n\n\n\n\n\nother: AFArray|Number|\nComplex\n|String\n \n\n\n\n\nAFArray:\n rhs array\n\n\nNumber:\n rhs number\n\n\nComplex\n:\n rhs complex value\n\n\nString:\n: rhs number value (to workaround JavaScript inability to hold int64 values)\n\n\n\n\n\n\n\n\nResult:\n AFArray instance holding the operation's result\n\n\nTODO\n\n\nas\n\n\nscalar!", 
            "title": "AFArray"
        }, 
        {
            "location": "/AFArray/#afarray-class", 
            "text": "", 
            "title": "AFArray class"
        }, 
        {
            "location": "/AFArray/#staitc-methods", 
            "text": "AFArray.create()  asynchronous, counterparts:  createAsync ,  createSync  Creates an AFArray instance of the specified dimensions, and copies data from the location specified by the buffer. Data can be reside on the host or on the device, the  source  argument specifies its location.   create(dim0, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, dim3, buffer, source, callback)   -  ArrayFire Documentation  create(dim0, dim1, dim2, dim4, buffer, source, callback)   -  ArrayFire Documentation  create(dims, buffer, source, callback)   -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimentsions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  source: value of  source  - can be one of the values of source object (eg.  source.host )   Result : the created AFArray instance.", 
            "title": "Staitc methods"
        }, 
        {
            "location": "/AFArray/#constructor", 
            "text": "Arrays could be created as empty ones or by having a specified dimensions and element type.    new AFArray() :  -  ArrayFire Documentation  new AFArray(dim0, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, type) :  -  ArrayFire Documentation  new AFArray(dim0, dim1, dim2, dim3, type) :  -  ArrayFire Documentation  new AFArray(dims, type) :  -  ArrayFire Documentation   Arguments:   dim0 .. dim3: Number  - size of the dimension  dims: Array| Dim4  - specifies sizes of the dimentsions, eg:  [2, 1, 1]  or  new Dim4(3, 4)  buffer: Buffer  - data to copy to the device, or device pointer created by the  alloc  method.  type: value of  dType  - can be one of the values of dType object (eg.  dType.f32 )   Remarks:  In Fire.js  type  argument is  not optional .", 
            "title": "constructor"
        }, 
        {
            "location": "/AFArray/#methods", 
            "text": "elements()  Get the number of elements in array.   elements()   -  ArrayFire Documentation   Result:  Number  host()  Copy array data to host.  asynchronous, counterparts:  hostAsync ,  hostSync   host(callback)   -  ArrayFire Documentation  host(buffer, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - to hold array's values, must be atleast the size of the array.   Result:  if buffer is not specified, then it will be created and returned, otherwise the result is  undefined  copyToHost()  alias of  host  write  Perform deep copy from host/device pointer to an existing array.   write(buffer, bytesToCopy, source, callback)   -  ArrayFire Documentation   Arguments:   buffer: Buffer  - data to copy to the array, or device pointer created by the  alloc  method.  bytesToCopy : bytes to copy  source: value of  source  - can be one of the values of source object (eg.  source.host )   type   type()   -  ArrayFire Documentation   Result:  array's element type, can be one of the values of  dType  object  dims   dims()   -  ArrayFire Documentation   Result:  array's dimensions info in a  Dim4  object instance  numdims   numdims()   -  ArrayFire Documentation   Result:  number of dimensions of the array  numDims  alias of  numdims  bytes   bytes()   -  ArrayFire Documentation   Result:  size of the array in bytes  copy   copy()   -  ArrayFire Documentation   Result:  new AFArray instance holding a deep copy of the array  isempty, isscalar, isvector, isrow, iscolumn, iscomplex, isreal, isdouble, issingle, isrealfloating, isfloating, isinteger, isbool  aliases respectively:  isEmpty ,  isScalar ,  isVector ,  isRow ,  isColumn ,  isComplex ,  isReal ,  isDouble ,  isSingle ,  isRealFloating ,  isFloating ,  isInteger ,  isBool     is anything ()  -  ArrayFire Documentation   Result:  actual type info (Boolean)  eval   eval()   -  ArrayFire Documentation   Evaluate any JIT expressions to generate data for the array.", 
            "title": "Methods"
        }, 
        {
            "location": "/AFArray/#indexing-operations", 
            "text": "at  -  ArrayFire Documentation   at(s0)  at(s0, s1)  at(s0, s1, s2)  at(s0, s1, s2, s3)   Arguments :    s0 .. s3: null|String|Number| Seq |AFArray     null:  means  \"span\"  String:  can be  \"span\"  Number:  element's index, or -1 which means the last element  Seq :  sequence of values  AFArray:  array holding the index value     Result:  AFArray instance holding reference to the the specified region of the original array  row, rows  Gets a reference of a row in a 2D AFArray.  -  ArrayFire Documentation   row(index)  rows(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a row index or a range of row indices   Result:  AFArray instance holding reference to the specified region of the original 2D array  col, cols  Gets a reference of a column in a 2D AFArray.  -  ArrayFire Documentation   col(index)  cols(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a column index or a range of column indices   Result:  AFArray instance holding reference to the specified region of the original 2D array  slice, slices  Gets a reference of a matrix in a 3D AFArray.  -  ArrayFire Documentation   slice(index)  slices(firstIndex, lastIndex)   Arguments :   index, fistIndex, lastIndex: Number  - a matrix index or a range of matrix indices   Result:  AFArray instance holding reference to the specified region of the original 3D array", 
            "title": "Indexing Operations"
        }, 
        {
            "location": "/AFArray/#operators", 
            "text": "Assignment Operators  -  ArrayFire Documentation   assign(other)  operator =  set(other)  operator = (alias of assign)  addAssign(other)  operator +=  subAssign(other)  operator -=  mulAssign(other)  operator *=  divAssign(other)  operator /=   Arguments :    other: AFArray|Number| Complex |String     AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  assignee AFArray instance  Arithmetic Operators  -  ArrayFire Documentation   add(other)  operator +  sub(other)  operator -  mul(other)  operator *  div(other)  operator /  bitshiftl(other)  operator   bitShiftL(other)  operator   (alias of bitshiftl)  bitshiftr(other)  operator   bitShiftR(other)  operator   (alias of bitshiftr)   Arguments :    other: AFArray|Number| Complex |String     AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  AFArray instance holding the operation's result  Logical Operators  -  ArrayFire Documentation   neg()  operator -  not()  operator !  lt(other)  operator   gt(other)  operator   le(other)  operator  =  ge(other)  operator  =  eq(other)  operator ==  neq(other)  operator !=  and(other)  operator   or(other)  operator ||  bitAnd(other)  operator   bitOr(other)  operator |  bitXor(other)  operator ^   Arguments :    other: AFArray|Number| Complex |String     AFArray:  rhs array  Number:  rhs number  Complex :  rhs complex value  String: : rhs number value (to workaround JavaScript inability to hold int64 values)     Result:  AFArray instance holding the operation's result", 
            "title": "Operators"
        }, 
        {
            "location": "/AFArray/#todo", 
            "text": "as  scalar!", 
            "title": "TODO"
        }, 
        {
            "location": "/Dim4/", 
            "text": "Dim4 class\n\n\nconstructors\n\n\n\n\nnew Dim4(dimArray)\n\n\nnew Dim4(dim0, dim1, dim2, dim3)\n\n\n\n\nArguments\n:\n\n\n\n\ndimArray: Array\n - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]\n\n\ndim0 .. dim3: Number\n - size of the dimension, default is 1\n\n\n\n\nProperties\n\n\ndims\n\n\nValue:\n \nArray\n containing the dimension sizes, eg.: two dimensions = \n[2, 3, 1, 1]\n, four dimensions = \n[2, 3, 4, 5]\n\n\nndims\n\n\nalias: \nnDims\n\n\nValue:\n number of dimensions\n\n\nelements\n\n\nValue:\n number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Dim4"
        }, 
        {
            "location": "/Dim4/#dim4-class", 
            "text": "", 
            "title": "Dim4 class"
        }, 
        {
            "location": "/Dim4/#constructors", 
            "text": "new Dim4(dimArray)  new Dim4(dim0, dim1, dim2, dim3)   Arguments :   dimArray: Array  - array holding dimension sizes, eg.: [1, 2], [1, 5, 6], [4, 5, 1, 1]  dim0 .. dim3: Number  - size of the dimension, default is 1", 
            "title": "constructors"
        }, 
        {
            "location": "/Dim4/#properties", 
            "text": "dims  Value:   Array  containing the dimension sizes, eg.: two dimensions =  [2, 3, 1, 1] , four dimensions =  [2, 3, 4, 5]  ndims  alias:  nDims  Value:  number of dimensions  elements  Value:  number of elements (dim0 * dim1 * dim2 * dim3)", 
            "title": "Properties"
        }, 
        {
            "location": "/Seq/", 
            "text": "Seq class\n\n\nconstructors\n\n\n\n\nnew Seq(begin, end)\n\n\nnew Seq(begin, end, step)\n\n\n\n\nArguments\n:\n\n\n\n\nbegin: Number\n - begin of sequence values\n\n\nend: Number\n - end of sequence values\n\n\nstep: Number\n - step size (default is 1)\n\n\n\n\nProperties\n\n\nbegin\n\n\nValue:\n begin of sequence values\n\n\nend\n\n\nValue:\n end of sequence values\n\n\nstep\n\n\nValue:\n step size", 
            "title": "Seq"
        }, 
        {
            "location": "/Seq/#seq-class", 
            "text": "", 
            "title": "Seq class"
        }, 
        {
            "location": "/Seq/#constructors", 
            "text": "new Seq(begin, end)  new Seq(begin, end, step)   Arguments :   begin: Number  - begin of sequence values  end: Number  - end of sequence values  step: Number  - step size (default is 1)", 
            "title": "constructors"
        }, 
        {
            "location": "/Seq/#properties", 
            "text": "begin  Value:  begin of sequence values  end  Value:  end of sequence values  step  Value:  step size", 
            "title": "Properties"
        }, 
        {
            "location": "/Complex/", 
            "text": "Complex class\n\n\nconstructor\n\n\n\n\nnew Complex(real, imag)\n\n\n\n\nArguments\n:\n\n\n\n\nreal: Number\n - real part of the value\n\n\nimag: Number\n - imaginary part of the value\n\n\n\n\nProperties\n\n\nreal\n\n\nValue:\n real part of the value\n\n\nimag\n\n\nValue:\n imaginary part of the value", 
            "title": "Complex"
        }, 
        {
            "location": "/Complex/#complex-class", 
            "text": "", 
            "title": "Complex class"
        }, 
        {
            "location": "/Complex/#constructor", 
            "text": "new Complex(real, imag)   Arguments :   real: Number  - real part of the value  imag: Number  - imaginary part of the value", 
            "title": "constructor"
        }, 
        {
            "location": "/Complex/#properties", 
            "text": "real  Value:  real part of the value  imag  Value:  imaginary part of the value", 
            "title": "Properties"
        }, 
        {
            "location": "/devices/", 
            "text": "Head 1\n\n\nHead 2\n\n\nHead 3", 
            "title": "Managing Devices"
        }, 
        {
            "location": "/devices/#head-1", 
            "text": "", 
            "title": "Head 1"
        }, 
        {
            "location": "/devices/#head-2", 
            "text": "", 
            "title": "Head 2"
        }, 
        {
            "location": "/devices/#head-3", 
            "text": "", 
            "title": "Head 3"
        }
    ]
}