{"version":3,"names":[],"mappings":"","sources":["machine-learning/mnist.js"],"sourcesContent":["\"use strict\";\n\nlet Bluebird = require(\"bluebird\");\nlet async = Bluebird.coroutine;\nlet fs = Bluebird.promisifyAll(require(\"fs-extra\"));\nlet ref = require(\"ref\");\nlet float = ref.types.float;\nlet uint = ref.types.uint;\nlet debug = require(\"debug\")(\"af:mnist\");\nlet _ = require(\"lodash\");\nlet assert = require(\"better-assert\");\nlet path = require(\"path\");\n\nlet readData = async(function*(f, data) {\n    let bytesRead = (yield fs.readAsync(f, data, 0, data.length, null))[0];\n    if (bytesRead !== data.length) {\n        throw new Error(\"File reading error!\");\n    }\n});\n\nlet readIdx = async(function*(path, type) {\n    let file = yield fs.openAsync(path, \"r\");\n    try {\n        let d = new Buffer(4);\n\n        yield readData(file, d);\n\n        if (d[2] != 8) {\n            throw new Error(\"Unsupported data type\");\n        }\n\n        const numDims = d[3];\n\n        // Read the dimensions\n        let elem = 1;\n        let dims = [];\n        for (let i = 0; i < numDims; i++) {\n            yield readData(file, d);\n            let dim = d.readUInt32BE();\n            elem *= dim;\n            dims.push(dim);\n        }\n\n        // Read the data\n        let bdata = new Buffer(elem);\n        yield readData(file, bdata);\n        let data = new Buffer(bdata.length * type.size);\n        for (let i = 0; i < bdata.length; i++) {\n            let byte = bdata[i];\n            type.set(data, i * type.size, byte);\n        }\n\n        return {\n            numDims: numDims,\n            dims: dims,\n            data: data\n        };\n    }\n    finally {\n        yield fs.closeAsync(file);\n    }\n});\n\nlet mnist = {\n    setup: async(function*(af, expandLabels, frac) {\n        frac = Math.min(frac || 1.0, 0.8);\n        let dataRoot = \"../../ml_lab/data/mnist\";\n        let AFArray = af.AFArray;\n        let Dim4 = af.Dim4;\n\n        let imageData = yield readIdx(path.join(dataRoot, \"images-subset\"), float);\n        let labelData = yield readIdx(path.join(dataRoot, \"labels-subset\"), uint);\n\n        let rIDims = new Dim4(_(imageData.dims).reverse().value());\n        let images = yield AFArray.createAsync(rIDims, af.dType.f32, imageData.data);\n\n        let r = af.randu(10000, af.dType.f32);\n        let cond = r.lt(frac);\n        let trainIndices = af.where(cond);\n        let testIndices = af.where(cond.not());\n\n        let trainImages = af.lookup(images, trainIndices, 2).div(255);\n        let testImages = af.lookup(images, testIndices, 2).div(255);\n\n        let numClasses = 10;\n        let numTrain = trainImages.dims(2);\n        let numTest = testImages.dims(2);\n\n        debug(`Training sample count: ${numTrain}`);\n        debug(`Test sample count: ${numTest}`);\n\n        let trainLabels;\n        let testLabels;\n\n        if (expandLabels) {\n            trainLabels = af.constant(0, numClasses, numTrain, af.dType.f32);\n            testLabels = af.constant(0, numClasses, numTest, af.dType.f32);\n\n            assert(trainIndices.type() === af.dType.u32);\n            assert(testIndices.type() === af.dType.u32);\n\n            let hTrainIdx = yield trainIndices.hostAsync();\n            let hTestIdx = yield testIndices.hostAsync();\n\n            for (let i = 0; i < numTrain; i++) {\n                let idx = uint.get(hTrainIdx, i * uint.size);\n                let label = uint.get(labelData.data, idx * uint.size);\n                assert(label >= 0 && label <= 9);\n                trainLabels.set(label, i, 1);\n            }\n\n            for (let i = 0; i < numTest; i++) {\n                let idx = uint.get(hTestIdx, i * uint.size);\n                let label = uint.get(labelData.data, idx * uint.size);\n                assert(label >= 0 && label <= 9);\n                testLabels.set(label, i, 1);\n            }\n        }\n        else {\n            let labels = yield AFArray.createAsync(labelData.dims[0], af.dType.u32, labelData.data);\n            trainLabels = labels.at(trainIndices);\n            testLabels = labels.at(testIndices);\n        }\n\n        return {\n            numClasses: numClasses,\n            numTrain: numTrain,\n            numTest: numTest,\n            trainImages: trainImages,\n            testImages: testImages,\n            trainLabels: trainLabels,\n            testLabels: testLabels\n        };\n    })\n};\n\nmodule.exports = mnist;"],"file":"machine-learning/mnist.js","sourceRoot":"/source/"}